<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<CSP name="doctypes/axdocbook/webpub.xsl" application="/csp/docbook/" default="1"><![CDATA[
<?xml version="1.0" encoding="utf-8"?>
<!--Copyright ArborText, Inc., 1999-2002-->
<!DOCTYPE xsl:stylesheet>

<?APT StylesheetID Title="DocBook Web" CompositionTypes="web,xsl"?>

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
<xsl:import href="../xdocbook/xsl/xhtml/docbook.xsl"/>
<xsl:include href="../../lib/xsl/common/version.xsl"/>
<xsl:output method="xml"/>
<xsl:variable name="html.stylesheet">viewer.css</xsl:variable>
<xsl:variable name="using.chunker" select="true()"/>

<!-- ******** Set toc generation parameter *********
     Since toc will be generated by chunker in comp for web,
     it is redundant to be generated again in content body.
     Here we set generate.toc to empty, so no toc will be generated.
     The following is the default settings for toc:
	<xsl:param name="generate.toc">
	set       toc
	book      toc,figure,table,example,equation
	/preface  toc
	/chapter  toc
	/appendix toc
	/article  toc
	/section  toc
	/part     toc,figure,example,table,equation
	/reference toc,figure,example,table,equation
	</xsl:param>
	****************************                       -->

<xsl:param name="generate.toc"/>

<!-- turn off index -->
<xsl:param name="generate.index" select='0'/>


<xsl:template match="processing-instruction('EpicOpts')">
  <xsl:processing-instruction name="EpicOpts">
    <xsl:value-of select="."/>
  </xsl:processing-instruction>
</xsl:template>

<xsl:template match="processing-instruction('ProfileValues')">
  <xsl:processing-instruction name="ProfileValues">
    <xsl:value-of select="."/>
  </xsl:processing-instruction>
</xsl:template>


<!-- If there is a Profile PI immediately before this node,
	we wrap the result in a span so that the profiling
	will apply to everything in this node
	(and not apply to what follows if this node is empty) -->
<xsl:template name="inline.charseq">
  <xsl:param name="content">
    <xsl:choose> 
      <xsl:when test='preceding-sibling::node()[1]=
		      preceding-sibling::processing-instruction("Profile")[1]'>
  	<span>
  	  <xsl:if test="@id">
  	    <a name="{@id}"/>
  	  </xsl:if>
  	  <xsl:apply-templates/>
  	</span>
      </xsl:when>
      <xsl:otherwise>
  	<xsl:if test="@id">
  	  <a name="{@id}"/>
  	</xsl:if>
  	<xsl:apply-templates/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:param>
  <xsl:copy-of select="$content"/>
</xsl:template>

<xsl:template match="processing-instruction('Profile')">
  <xsl:processing-instruction name="Profile">
    <xsl:value-of select="."/>
  </xsl:processing-instruction>

  <!-- Now we need to create a ProfileAxes PI with attributes based on 
       the "attributes" of the Profile PI and the attributes of the next node.
       The data of each PI is just a string that looks like attributes,
       e.g., 'foo="bar" stuff="nonsense"': -->

  <xsl:processing-instruction name="ProfileAxes">
    <xsl:call-template name="check-Profile-atts">
      <xsl:with-param name="target-atts" select="following-sibling::*[1]/@*"/>
      <xsl:with-param name="PI-data" select="string(current())"/>
    </xsl:call-template>
  </xsl:processing-instruction>

</xsl:template>

<xsl:template name="check-Profile-atts">
  <xsl:param name="target-atts"/>
  <xsl:param name="PI-data"/>
   
  <!-- Anything up to the first = is a profile attribute name: -->
  <xsl:call-template name="check-Profile-att">
    <xsl:with-param name="target-atts" select="$target-atts"/>
    <xsl:with-param name="PI-att" select="substring-before($PI-data, '=')"/>
  </xsl:call-template>

  <!-- If there are more (as indicated by " followed by a blank), 
       remove the first one and its value and recurse: -->
  <xsl:if test="contains($PI-data, '&#34; ')">
    <xsl:call-template name="check-Profile-atts">
      <xsl:with-param name="target-atts" select="$target-atts"/>
      <xsl:with-param name="PI-data" select="substring-after($PI-data, '&#34; ')"/>
    </xsl:call-template>
  </xsl:if>

</xsl:template>

<xsl:template name="check-Profile-att">
  <xsl:param name="target-atts"/>
  <xsl:param name="PI-att"/>
  <!-- step through the attributes of the target node
       checking for a match with the profile attribute:  -->
  <xsl:for-each select="$target-atts">
    <xsl:if test="name()=$PI-att">
      <!-- match found:  output into the PI data in the form of an "attribute" -->
      <xsl:value-of select="name()"/>
      <xsl:text>="</xsl:text>
      <xsl:value-of select="string(current())"/>
      <xsl:text>" </xsl:text>  
    </xsl:if>
  </xsl:for-each>
</xsl:template>

<xsl:template match="indexterm">
   <indexterm primary="{primary}"
              secondary="{secondary}"
              tertiary="{tertiary}"
              see="{see}"
              seealso="{seealso}"
              preferred="{preferred}">
     <xsl:attribute name="id">
          <xsl:call-template name="object.id"/>
     </xsl:attribute>
   </indexterm>
</xsl:template>

<xsl:template name="inline.underlineseq">
  <xsl:param name="content">
    <xsl:apply-templates/>
  </xsl:param>
  <u><xsl:copy-of select="$content"/></u>
</xsl:template>

<xsl:template match="emphasis[@role='bold']">
  <xsl:call-template name="inline.boldseq"/>
</xsl:template>

<xsl:template match="emphasis[@role='underline']">
  <xsl:call-template name="inline.underlineseq"/>
</xsl:template>

<!-- user.head.content is applied to add a meta tag 
	to insert epic application information. -->
<xsl:template name="user.head.content">
  <xsl:param name="node" select="."/>
  <meta name="generator" content="{$generator-product-name} {$generator-version-no}"/>
</xsl:template>

<!-- Arbortext has a graphics conversion process that results in the image being
     scaled so we need to override the usual processing so we don't scale twice. -->

<xsl:template name="process.image">
  <!-- When this template is called, the current node should be  -->
  <!-- a graphic, inlinegraphic, imagedata, or videodata. All    -->
  <!-- those elements have the same set of attributes, so we can -->
  <!-- handle them all in one place.                             -->
  <xsl:param name="tag" select="'img'"/>
  <xsl:param name="alt"/>

  <xsl:variable name="input-filename">
    <xsl:choose>
      <xsl:when test="@entityref">
        <xsl:value-of select="unparsed-entity-uri(@entityref)"/>
      </xsl:when>
      <xsl:when test="@fileref">
        <xsl:value-of select="@fileref"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:message>
          <xsl:text>Expected @entityref or @fileref on </xsl:text>
          <xsl:value-of select="name(.)"/>
        </xsl:message>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="fileext">
    <xsl:call-template name="filename-extension">
      <xsl:with-param name="filename" select="$input-filename"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="filename">
    <xsl:choose>
      <xsl:when test="$fileext != ''">
        <xsl:value-of select="$input-filename"/>
      </xsl:when>
      <xsl:when test="$graphic.default.extension != ''">
        <xsl:value-of select="$input-filename"/>
        <xsl:value-of select="$graphic.default.extension"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$input-filename"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="width">
    <xsl:choose>
      <xsl:when test="@width"><xsl:value-of select="@width"/></xsl:when>
      <xsl:otherwise></xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="height">
    <xsl:choose>
      <xsl:when test="@depth"><xsl:value-of select="@depth"/></xsl:when>
      <xsl:otherwise></xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="align">
    <xsl:value-of select="@align"/>
  </xsl:variable>

  <xsl:element name="{$tag}">
    <xsl:attribute name="src">
      <xsl:value-of select="$filename"/>
    </xsl:attribute>

    <xsl:if test="$align != ''">
      <xsl:attribute name="align">
        <xsl:value-of select="$align"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="$height != ''">
      <xsl:attribute name="height">
        <xsl:value-of select="$height"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="$width != ''">
      <xsl:attribute name="width">
        <xsl:value-of select="$width"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="$alt != ''">
      <xsl:attribute name="alt">
        <xsl:value-of select="$alt"/>
      </xsl:attribute>
    </xsl:if>
  </xsl:element>
</xsl:template>


<!-- ================================================================ -->
<!-- ================================================================ -->
<!--                                                                  -->
<!-- Here we include overriding templates that update those in        -->
<!-- the distributed stylesheets.                                     -->
<!--                                                                  -->
<!-- ================================================================ -->
<!-- ================================================================ -->

<xsl:include href="xsl/xhtml/axdocbook-updates.xsl"/>

</xsl:stylesheet>

]]></CSP>
</Export>
