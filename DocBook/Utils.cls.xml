<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="DocBook.Utils">
<Description>
Utility class</Description>
<ClassType/>
<IncludeCode>%occSAX,DocBookMac</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Library.RegisteredObject</Super>
<TimeCreated>58822,45005</TimeCreated>

<Method name="Help">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Write $$$T("To load an xml file:"),!
    Write "Do ##class(DocBook.Utils).Load(file)",!
    Write !
    Write $$$T("To load a book and related files:"),!
    Write "Do ##class(DocBook.Utils).LoadBook(bookid)",!
    Write !
    Write $$$T("To load the entire Doc Set:"),!
    Write "Do ##class(DocBook.Utils).LoadSets()",!
]]></Implementation>
</Method>

<Method name="IsDeveloper">
<Description>
Returns 1 if the user has permission to access the class documentation</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[    Quit ($system.Security.Check("%Development","use"))
]]></Implementation>
</Method>

<Method name="IsISC">
<Description>
Returns 1 if the user has permission to access the class documentation</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[    Quit (("," _ $ROLES _ ",") [ ",ISC_Internal,")
]]></Implementation>
</Method>

<Method name="UsingJapanese">
<Description>
Returns 1 if we are dealing with Japanese text</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[    Quit ($GET(^DocBook.Config("INDEXCLASS"), "empty")="DocBook.IndexedTextJ")
]]></Implementation>
</Method>

<Method name="EnsembleLoaded">
<Description>
Checks to see if Ensemble is loaded in any accessible namespace</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
    SET present = $GET(^DocBook.Config("ARCHITECTURES","ENSEMBLE"), 0)
    Quit:(present > 0) 1

    Quit:(##class(%Library.EnsembleMgr).IsEnsembleInstalled() > 0) 1

    // test for faking it
    //Quit:($DATA(^DocBook.Config("EnsembleLoaded")) > 0) $GET(^DocBook.Config("EnsembleLoaded"), 0)

    // nope
    Quit 0
]]></Implementation>
</Method>

<Method name="HealthShareLoaded">
<Description>
Checks to see if HealthShare is loaded in any accessible namespace</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
    SET present = $GET(^DocBook.Config("ARCHITECTURES","HEALTHSHARE"), 0)
                + $GET(^DocBook.Config("ARCHITECTURES","HSFOUNDATION"), 0)
    Quit:(present > 0) 1

    Quit:(##class(%Library.EnsembleMgr).IsHealthShareInstalled() > 0) 1

    // test for faking it
    //Quit:($DATA(^DocBook.Config("HealthShareLoaded")) > 0) $GET(^DocBook.Config("HealthShareLoaded"), 0)

    // nope
    Quit 0
]]></Implementation>
</Method>

<Method name="TrakCareLoaded">
<Description>
Checks to see if TrakCare is loaded in any accessible namespace</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
    SET present = $GET(^DocBook.Config("ARCHITECTURES","HEALTHSHARE"), 0)
    Quit:(present > 0) 1

    // This replicates the check in %Library.EnsembleMgr
    // without the restriction of checking to see if it
    // is enabled in the current namespace
    Quit:($DATA(^%SYS("TrakCare")) > 0) 1

    // test for faking it
    //Quit:($DATA(^DocBook.Config("TrakCareLoaded")) > 0) $GET(^DocBook.Config("TrakCareLoaded"), 0)

    // nope
    Quit 0
]]></Implementation>
</Method>

<Method name="ShowConfigSettings">
<Description>
Show the various configuration settings</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[

    do ##class(DocBook.ConfigUtils).DisplayConfigParams()
    quit
]]></Implementation>
</Method>

<Method name="ShowSearchDirs">
<Description>
Show the search paths available</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>main:cdata=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    set dirlist = ##class(SearchUtils).BuildSearchList(main)
    Set sc = $$$OK

    If (dirlist.Count() = 0)
    {
        Write $$$T("Search directory list is empty"), !
    }
    Else
    {
        Write $$$T("Search directories: "), dirlist.Count(), !
        For i = 1 : 1 : dirlist.Count()
        {
            Write i, "-", dirlist.GetAt(i), !
        }
    }
    quit sc
]]></Implementation>
</Method>

<Method name="GetMachineName">
<Description>
Show the search paths available</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[

    Set sysname = $zu(54,13,$zu(54,0))
    If ($LENGTH(sysname, ",") > 1)
    {
        If ($LENGTH($PIECE(sysname, ",", 2)) > 0)
        {
            Set sysname = $PIECE(sysname, ",", 2)
        }
        Else
        {
            Set sysname = $PIECE(sysname, ",", 1)
        }
    }

    Quit sysname
]]></Implementation>
</Method>

<Method name="CheckEncoding">
<Description>
Sieve out invalid encoding declarations</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    // try to get the file
    Open filename:("RS"):2 Else  Write "CheckEncoding: ", $$$T("Unable to open file: "), filename, ! QUIT "<MissingFofile>"
    Set SaveIO=$io
    Use filename

    // get the first line
    Read FirstLine:2

    // swifth back no matter what the result
    Use SaveIO
    Close filename

    // check what we got
    Quit:(FirstLine [ "encoding=""UTF-8""") ""
    Quit:(FirstLine [ "encoding=""utf-8""") ""
    Quit FirstLine
]]></Implementation>
</Method>

<Method name="Load">
<Description>
Load an individual doc file</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>file,validate:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    Set sc = $$$OK

    // !!!Force index to get rebuilt
    Kill ^DocBook.Index

    Set mask =  $$$SAXSTARTENTITY + $$$SAXENDENTITY + $$$SAXCONTENTEVENTS

    If (##class(%XML.Catalog).IsEmpty()) {
        Write $$$T("ERROR: DocBook.Utils:Load() The XML Catalog is empty."),!
        Quit $$$ERROR($$$GeneralError,$$$T("XML Catalog Empty"))
    }

    If ('##class(%File).Exists(file)) {
        Write $$$T("ERROR:"), " DocBook.Utils:Load() ", $$$T("File "), file, $$$T(" not found."),!
        Quit $$$ERROR($$$GeneralError, ($$$T("File not found: ") _ file))
    }

    Set resolve = ##Class(%XML.CatalogResolver).%New()

    Write $$$T("Loading: ") ,file, " ", !

    Set enc = ..CheckEncoding(file)
    If ($LENGTH(enc) > 0)
    {
        Write $$$T("----- Assertion Failure: "), $$$T("Unrecognized file encoding -- "), enc, !
    }


    If $D(%response) {
        // assume we are called from CSP
        Do %response.Flush()
    }

    Set h = ##Class(DocBookParser).%New()
    Set fname = ##class(%File).GetFilename(file)
    Set h.SourceFile = fname
    Set h.SourceTime = $ZDT(##class(%File).GetFileDateModified(file),3)

    // reset error log
    Do ##class(ErrorLog).ResetForFile(fname)

    Set sc = ##class(%XML.SAX.Parser).ParseFile(file, h, resolve, validate + $$$SAXNAMESPACES, mask)
    If ($system.Status.IsError(sc))
    {
        Do $system.OBJ.DisplayError(sc)
    }

    If $D(%response) {
        Write !
        // assume we are called from CSP
        Do %response.Flush()
    }

    ; clean up
    Set resolve = ""
    Set h = ""

    Quit sc
]]></Implementation>
</Method>

<Method name="LoadSetList">
<Description>
Load a SetList document</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>file</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    Set sc = $$$OK

    Write $$$T("Loading: ") , file, " ", !
    Set h = ##Class(SetListParser).%New()

    Set fname = ##class(%File).GetFilename(file)

    // reset error log
    Do ##class(ErrorLog).ResetForFile(fname)

    Set sc =  ##class(%XML.SAX.Parser).ParseFile(file,h,,0)
    Set h.SourceFile = fname
    Set h.SourceTime = $ZDT(##class(%File).GetFileDateModified(file),3)

    If ($system.OBJ.IsError(sc)) {
        Do $system.OBJ.DisplayError(sc)
    }

    ; Write !
    Set h = ""
    Quit sc
]]></Implementation>
</Method>

<Method name="Classify">
<Description>
Set up the material classificaton for the home page</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do ##class(DocBook.Taxonomy).Define()

    Do ##class(DocBook.Taxonomy).Check()

    Quit $$$OK
]]></Implementation>
</Method>

<Method name="CheckColoring">
<Description>
Invokes the class to list any coloring errors noted in the database</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    ; merely invoke the new class
    Do ##class(DocBook.CheckColor).Main()

    Quit
]]></Implementation>
</Method>

<Method name="CheckWideChars">
<Description>
This method scans all the text for characters outside the range 0-255</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    ; there is no check to see if we are running on a Unicode system.
    ;  If we are not, this will fail with a <WIDECHAR> error anyway.
    Set Tick = 1000
    Set Found = 0
    Set MaxBlock = ^DocBook.blockD
    Write !
    Write $$$T("Scan for wide characters"), !
    Write $$$T("Maximum block number: "), $FNUMBER(MaxBlock, ","), !

    Set ErrPfx = $$$T("WARNING: Wide Char; ")

    For Blk = 1 : 1 : MaxBlock
    {
        ;Write:((Blk # Tick) = 0) Blk, !

        Set B = ##class(DocBook.block).%OpenId(Blk)
        If (B '= $$$NULLOREF)
        {
            ;Write B.sourcefile, !

            If ($ZISWIDE(B.title))
            {
                Set Found = Found + 1
                Write ErrPfx, $$$T("File:"), " ", B.sourcefile, "; ", $$$T("Block:"), " ", Blk, !
                Write $$$T("Title--"), !
                Set B.title = ..ProcessWideChars(B.title)
                ;Write B.title, !
                Do B.%Save()
            }

            If ($ZISWIDE(B.content))
            {
                Set Found = Found + 1
                Write ErrPfx, $$$T("File:"), " ", B.sourcefile, "; ", $$$T("Block:"), " ",  Blk, !
                Write $$$T("Content--"), !
                Set B.content = ..ProcessWideChars(B.content)
                ;Write B.content, !
                Do B.%Save()
            }

            If ($ZISWIDE(B.renderedContent))
            {
                Set Found = Found + 1
                Write ErrPfx, $$$T("File:"), " ", B.sourcefile, "; ", $$$T("Block:"), " ",  Blk, !
                Write $$$T("RenderedContent--"), !
                Set B.renderedcontent = ..ProcessWideChars(B.renderedContent)
                ;Write B.renderedcontent, !
                Do B.%Save()
            }
        }
        Set B = ""
    }
    Write:(Found '= 0) $$$T("Components found:"), " ", $FNUMBER(Found, ","), !
    Write $$$T("Done"), !

    Quit
]]></Implementation>
</Method>

<Method name="ProcessWideChars">
<Description>
This method scans all the text for characters outside the range 0-255</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>text:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set Result = ""
    For I = 1 : 1 : $LENGTH(text)
    {
        Set C = $EXTRACT(text, I, I)
        If ($ZISWIDE(C))
        {
            Set Val = $ASCII(C)
            Write $$$T("Position: "), I, "; ", $$$T("Value: "), Val, " (0x", $ZHEX(Val), ")", "; ", $$$T("Glyph: "), C, !
            Set C = "?"
        }
        Set Result = Result _ C
    }

    Quit Result
]]></Implementation>
</Method>

<Method name="DisplayWideChars">
<Description>
This method scans all the text for characters outside the range 0-255</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>text:%String</FormalSpec>
<Implementation><![CDATA[
    For I = 1 : 1 : $LENGTH(text)
    {
        Set C = $EXTRACT(text, I, I)
        If ($ZISWIDE(C))
        {
            Set Val = $ASCII(C)
            Write $$$T("Position: "), I, "; ", $$$T("Value: "), Val, " (0x", $ZHEX(Val), ")", "; ", $$$T("Glyph: "), C, !
        }
    }

    Quit
]]></Implementation>
</Method>

<Method name="RebuildIndices">
<Description>
Rebuilds the indices for the database</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>display:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    ; remove the old indexes
    Kill ^DocBook.Index
    Kill ^DocBook.Anchor

    ; build the new ones
    Write:(+display) !
    Write:(+display) $$$T("Building Master Index: ")
    Do ##class(DocBook.Utils).BuildIndex()
    Write:(+display) "[", ##class(DocBook.Utils).CountGlobal("^DocBook.Index"), "] "
    Write:(+display) "OK", !

    Write:(+display) $$$T("Building Help Index: ")
    Do ##class(DocBook.Utils).BuildAnchorIndex()
    Write:(+display) "[", ##class(DocBook.Utils).CountGlobal("^DocBook.Anchor"), "] "
    Write:(+display) "OK", !

    quit
]]></Implementation>
</Method>

<Method name="LoadSets">
<Description>
Reset and load the master documents.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>main:cdata=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    // display the config settings
    do ..ShowConfigSettings()
    // if no directory provided, use search paths
    do ..ShowSearchDirs(main)
    set dirlist = ##class(SearchUtils).BuildSearchList(main)
    Set sc = $$$OK

    If (dirlist.Count() = 0) {
        Write $$$T("Source Location not specified.")
        Quit $$$ERROR($$$GeneralError,("DocBook.Utils:LoadSets() " _ $$$T("DocBook Source not specified")))
    }

    Set ^DocBook.OffLine = 1

    Write $$$T("Resetting..."),!
    Do ..Reset()
    Do ..ResetLog()

    Write $$$T("Building on "), ..GetBuildInfo(0), !

    // Get Sets
    Set filelist = ##class(SearchUtils).LocateFiles(dirlist, "SET*.xml")
    If (filelist.Count() = 0)
    {
        Write $$$T("No sets found.")
        Quit $$$ERROR($$$GeneralError,("DocBook.Utils:LoadSets() " _ $$$T("No SETs found.")))
    }

    For i = 1 : 1 : filelist.Count()
    {
        Do ..Load(filelist.GetAt(i))
        If $get(^%SYS("DOCBOOK","KINGTUT")) Quit
    }
    Set filelist = ""

    Kill ^DocBook.Config("ARCHITECTURES")

    // Now load books referenced by sets

    &sql(DECLARE BL CURSOR FOR
         SELECT blockid INTO :bid FROM book)

    &sql(OPEN BL)
    &sql(FETCH BL)
    If (SQLCODE '= 0)
    {
        Write $$$T("SQL Error finding first book:"), SQLCODE, !
    }

    While (SQLCODE = 0) {
        Write !, " [" ,bid, "]", !

        Set bookdirlist = ##class(SearchUtils).ExtendSearchList(dirlist, bid)
        Set filelist = ##class(SearchUtils).LocateFiles(bookdirlist, (bid _ ".xml"))
        If (filelist.Count() > 0)
        {
            Set thefilepath = filelist.GetAt(1)
            Set thedirpath = ##class(%File).GetDirectory(thefilepath)
            Set loaddir = ##class(SearchUtils).ContainingDir(thedirpath)
            Do ..LoadBook(bid, loaddir)
        }
        &sql(FETCH BL)
    }

    &sql(CLOSE BL)

    // Load Articles
    write !, " [Articles]", !
    Set bookdirlist = ##class(SearchUtils).ExtendSearchList(dirlist, "Articles")
    Set filelist = ##class(SearchUtils).LocateFiles(bookdirlist, "*.xml")
    if (filelist.Count() > 0)
    {
        ; load each separately in case articles are in different directories
        For i = 1 : 1 : filelist.Count()
        {
            Set thefilepath = filelist.GetAt(i)
            Do ..Load(thefilepath)
            If $get(^%SYS("DOCBOOK","KINGTUT")) Quit
        }
    }

    // (re)build infrastructure
    Write !
    Do ..CheckColoring()
    Do:(##class(DocBook.ConfigUtils).GetWIDECHARCHECK()) ..CheckWideChars()
    Do ..RebuildIndices(1)

    Set sc = ..Classify()

    Kill ^DocBook.OffLine

    Set ^DocBook.LoadTime = $ZDT($H,3)

    Quit sc
]]></Implementation>
</Method>

<Method name="ReplaceSet">
<Description>
Replaces a set and its books.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>setname:cdata="",main:cdata=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    // if no directory provided, use search paths
    do ..ShowSearchDirs(main)
    set dirlist = ##class(SearchUtils).BuildSearchList(main)
    Set sc = $$$OK

    If (dirlist.Count() = 0) {
        Write $$$T("Source Location not specified.")
        Quit $$$ERROR($$$GeneralError,("DocBook.Utils:ReplaceSet() " _ $$$T("DocBook Source not specified")))
    }

    // Get Sets
    Set SetName = setname _ ".xml"
    Set filelist = ##class(SearchUtils).LocateFiles(dirlist,SetName)
    If (filelist.Count() = 0)
    {
        Write "No set found."
        Quit $$$ERROR($$$GeneralError,("DocBook.Utils:ReplaceSet() " _ $$$T("No SETs found.")))
    }
    If (filelist.Count() > 1)
    {
        Write "Duplicate sets found."
        Quit $$$ERROR($$$GeneralError,("DocBook.Utils:ReplaceSet() " _ $$$T("Duplicate SETs found.")))
    }

    ; if there is a previously loaded set, remove it
    set setblock = 0
    &sql(DECLARE OLDSET CURSOR FOR
         SELECT ID
         INTO :setblock
         FROM DocBook.db_set
         WHERE blockid = :SetName)
    &sql(OPEN OLDSET)
    &sql(FETCH OLDSET)
    if (SQLCODE = 0)
    {
        set deletestatus = ##class(DocBook.set).%DeleteId(setblock)
        if (deletestatus '= $$$OK)
        {
            Quit $$$ERROR(deletestatus,("DocBook.Utils:ReplaceSet() " _ $$$T("Delete error.")))
        }
    }
    &sql(CLOSE OLDSET)

    Do ..Load(filelist.GetAt(1))
    Set filelist = ""

    ; now get the book directories
    set articles = 0
    set DirList = ##class(%Library.ResultSet).%New("%Library.File:FileSet")
    set Pattern = "*"
    set dirliststatus = DirList.Execute(main, Pattern, "", 1)
    if (dirliststatus '= $$$OK)
    {
        Quit $$$ERROR(dirliststatus,("DocBook.Utils:ReplaceSet() " _ $$$T("FileSet error.")))
    }
    while (DirList.Next() '= 0)
    {
        set type = DirList.GetData(2)
        if (type [ "D")
        {
            set BookName = DirList.GetData(6)
            set BookPath = DirList.GetData(1)
            ;write "BookName: ", BookName, !
            ;write "BookPath: ", BookPath, !
            ;write "Type: ", type, !
            if ($ZCONVERT(BookName, "U") '[ "ARTICLES")
            {
                set loadstatus = ##class(DocBook.Utils).LoadBook(BookName, main)
                if (loadstatus '= $$$OK)
                {
                    Quit
                }
            }
        }
    }

    do DirList.Close()
    set DirList = ""

    write !, " [Articles]", !
    Set bookdirlist = ##class(SearchUtils).ExtendSearchList(dirlist, "Articles")
    Set filelist = ##class(SearchUtils).LocateFiles(bookdirlist, "*.xml")
    if (filelist.Count() > 0)
    {
        ; load each separately in case articles are in different directories
        For i = 1 : 1 : filelist.Count()
        {
            Set thefilepath = filelist.GetAt(i)
            Do ..Load(thefilepath)
        }
    }
    Set filelist = ""

    ; now rebuild the indices
    Write $$$T("Building Master Index: ")
    Do ##class(DocBook.Utils).BuildIndex()
    Write "[", ##class(DocBook.Utils).CountGlobal("^DocBook.Index"), "] "
    Write "OK", !

    Quit sc
]]></Implementation>
</Method>

<Method name="LoadSet">
<Description>
Load (reload) a set.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>setname:cdata="",main:cdata=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    // if no directory provided, use search paths
    do ..ShowSearchDirs(main)
    set dirlist = ##class(SearchUtils).BuildSearchList(main)
    Set sc = $$$OK

    If (dirlist.Count() = 0) {
        Write $$$T("Source Location not specified.")
        Quit $$$ERROR($$$GeneralError,("DocBook.Utils:LoadSets() " _ $$$T("DocBook Source not specified")))
    }

    // Get Sets
    Set filelist = ##class(SearchUtils).LocateFiles(dirlist,(setname _ ".xml"))
    If (filelist.Count() = 0)
    {
        Write $$$T("No set found.")
        Quit $$$ERROR($$$GeneralError,("DocBook.Utils:LoadSet() " _ $$$T("No SETs found.")))
    }
    If (filelist.Count() > 1)
    {
        Write $$$T("Duplicate sets found.")
        Quit $$$ERROR($$$GeneralError,("DocBook.Utils:LoadSet() " _ $$$T("Duplicate SETs found.")))
    }

    For i = 1 : 1 : filelist.Count()
    {
        Do ..Load(filelist.GetAt(i))
    }
    Set filelist = ""

    // Find the blockid of the set we just loaded

    // Find the set we just loaded

    &sql(DECLARE SETLOADED CURSOR FOR
         SELECT ID INTO :setid FROM book WHERE %SQLUPPER(blockid) = %SQLUPPER(:setname))
    &sql(OPEN SETLOADED)
    &sql(FETCH SETLOADED)
    If (SQLCODE '= 0)
    {
        Write $$$T("Set ID not found.")
        Quit $$$ERROR($$$GeneralError,("DocBook.Utils:LoadSet() " _ $$$T("Set ID not found.")))
    }
    &sql(CLOSE SETLOADED)

    &sql(DECLARE SETBOOKS CURSOR FOR
         SELECT blockid INTO :bid FROM book WHERE container = :setid)
    &sql(OPEN SETBOOKS)
    &sql(FETCH SETBOOKS)

    While (SQLCODE = 0) {
        Write !, " [" ,bid, "]", !

        Set bookdirlist = ##class(SearchUtils).ExtendSearchList(dirlist, bid)
        Set filelist = ##class(SearchUtils).LocateFiles(bookdirlist, (bid _ ".xml"))
        If (filelist.Count() > 0)
        {
            Set thefilepath = filelist.GetAt(1)
            Set thedirpath = ##class(%File).GetDirectory(thefilepath)
            Set loaddir = ##class(SearchUtils).ContainingDir(thedirpath)
            Do ..LoadBook(bid, loaddir)
        }
        &sql(FETCH SETBOOKS)
    }

    &sql(CLOSE SETBOOKS)

    Quit sc
]]></Implementation>
</Method>

<Method name="LoadBook">
<Description>
Load an entire book definition</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>book:cdata,subdir:cdata=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    // get places to look
    set searchlist = ##class(SearchUtils).BuildSearchList(subdir)
    set dirlist = ##class(SearchUtils).ExtendSearchList(searchlist, book)

    Set sc = $$$OK

    set filelist = ##class(SearchUtils).LocateFiles(dirlist, (book _ ".xml"))
    If (filelist.Count() = 0)
    {
        Write $$$T("No book found: "), book, !
        set sc =  $$$ERROR($$$GeneralError, ("DocBook.Utils:LoadBook() " _ $$$T("No book found: ") _ book))
    }
    else
    {
        set loaddir = ##class(%File).GetDirectory(filelist.GetAt(1))
        do ..LoadMaster(loaddir)
        Do ..LoadDir(loaddir)
    }

    Quit sc
]]></Implementation>
</Method>

<Method name="LoadMaster">
<Description>
Load the master file for the given directory</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>subdir:cdata</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    Set subdir = ##class(%File).NormalizeDirectory(subdir)
    Set dirname = ##class(SearchUtils).GetDirectoryname(subdir)
    set searchlist = ##class(SearchUtils).BuildSearchList(subdir)
    set filelist = ##class(SearchUtils).LocateFiles(searchlist, (dirname _ ".xml"))
    if (filelist.Count() > 0)
    {
        set sc = ..Load(filelist.GetAt(1))
    }
    else
    {
        //Write $$$T("ERROR:"), " DocBook.Utils:LoadMaster() ", $$$T("Book master not found: "), dirname, !
        //set sc = $$$ERROR($$$GeneralError,$$$T("Book master file missing."))
    }

    Quit sc
]]></Implementation>
</Method>

<Method name="LoadDir">
<Description>
Load every non-master file in the given directory</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>subdir:cdata</FormalSpec>
<Implementation><![CDATA[

    Set subdir = ##class(%File).NormalizeDirectory(subdir)

    Set dir = ##class(%ResultSet).%New("%File.FileSet")
    Do dir.Execute(subdir, "*.xml")
    ; Write !
    ; write "Subdir: ", subdir, !

    While (dir.Next()) {
        Set path = dir.GetData(1)
        set file = ##class(%Library.File).GetFilename(path)
        set dirpath = ##class(%Library.File).GetDirectory(path)
        set dirname = ##class(SearchUtils).GetDirectoryname(dirpath)
        ;write "Path: ", path, !
        ;write "DirPath: ", dirpath, !
        ;write "DirName: ", dirname, !
        ;write "File: ", file, !

        If ($ZCONVERT(file, "L") = ($ZCONVERT(dirname, "L") _ ".xml"))
        {
            ; Write $$$T("Master file already loaded: "), file, !
        }
        Else
        {
            ; Write path, !
            Set sc = ..Load(path)
        }
    }

    Quit $$$OK
]]></Implementation>
</Method>

<Method name="RemoveArticle">
<Description>
Remove an article from the database</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ArticleName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    Set name = ArticleName

    &sql(DECLARE THEARTICLE CURSOR FOR
         SELECT ID
         INTO :blockno
         FROM DocBook.article
         WHERE blockid = :name)
    &sql(OPEN THEARTICLE)
    &sql(FETCH THEARTICLE)
    if (SQLCODE = 0)
    {
        Write $$$T("Deleting block: "), blockno, !
        Do ##class(DocBook.article).%DeleteId(blockno)
        set sc = $$$OK
    }
    else
    {
        Write $$$T("ERROR:"), " DocBook.Utils:RemoveArticle() - ", $$$T("No article by that name."),!
        set sc = $$$ERROR($$$GeneralError,$$$T("No such article"))
    }
    &sql(CLOSE THEARTICLE)

    quit sc
]]></Implementation>
</Method>

<Method name="RemoveBook">
<Description>
Remove a book from the database</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>BookName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    Set name = BookName

    &sql(DECLARE THEBOOK CURSOR FOR
         SELECT ID
         INTO :blockno
         FROM DocBook.book
         WHERE blockid = :name)
    &sql(OPEN THEBOOK)
    &sql(FETCH THEBOOK)
    if (SQLCODE = 0)
    {
        Write $$$T("Deleting block: "), blockno, !
        Do ##class(DocBook.book).%DeleteId(blockno)
        set sc = $$$OK
    }
    else
    {
        Write $$$T("ERROR: DocBook.Utils:RemoveBook()  - No book by that name."),!
        set sc = $$$ERROR($$$GeneralError,$$$T("No such article"))
    }
    &sql(CLOSE THEBOOK)

    quit sc
]]></Implementation>
</Method>

<Method name="RemoveSet">
<Description>
Remove a set from the database</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>SetName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    Set name = SetName

    &sql(DECLARE THESET CURSOR FOR
         SELECT ID
         INTO :blockno
         FROM DocBook.db_set
         WHERE blockid = :name)
    &sql(OPEN THESET)
    &sql(FETCH THESET)
    if (SQLCODE = 0)
    {
        Write $$$T("Deleting block: "), blockno, !
        Do ##class(DocBook.set).%DeleteId(blockno)
        set sc = $$$OK
    }
    else
    {
        Write $$$T("ERROR:"), " DocBook.Utils:RemoveBook()  - ", $$$T("No set by that name."),!
        set sc = $$$ERROR($$$GeneralError,$$$T("No such set"))
    }
    &sql(CLOSE THESET)

    quit sc
]]></Implementation>
</Method>

<Method name="CheckProgramlistings">
<Description>
Loads the DocBook application</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set MarkerBgn = "DLLResultCode:"
    Set MarkerEnd = "-->"

    Set SEP = "//"

    // build the query to look for errors
    Set SELECT = "SELECT ID, sourcefile, dblang, errorLang, renderedContent"
    Set FROM = "FROM DocBook.programlisting"
    Set WHERE = "WHERE ($FIND(renderedContent, '" _ MarkerBgn _ "') > 0)"
    Set STMT = SELECT _ " " _ FROM _ " " _ WHERE
    //Write "Stmt: ", SELECT, !, "..... ", FROM, !, "..... ", WHERE, !

    Set RS = ##class(%Library.ResultSet).%New("%DynamicQuery:SQL")
    Set sc = RS.Prepare(STMT)
    If ($$$ISERR(sc))
    {
        Write $$$T("Error attempting to prepare query"), !
        Do $SYSTEM.Status.DisplayError(sc)
        Quit sc
    }
    Set sc = RS.Execute()
    If ($$$ISERR(sc))
    {
        Write $$$T("Error attempting to execute query"), !
        Do $SYSTEM.Status.DisplayError(sc)
        Quit sc
    }

    Set ErrorTotal = 0
    While (RS.Next())
    {
        Set ErrorTotal = ErrorTotal + 1

        Set ThisID = $GET(RS.Data("ID"))
        Set ThisFile = $GET(RS.Data("sourcefile"))
        Set ThisLang = $GET(RS.Data("dblang"))
        Set ThisErrLang = $GET(RS.Data("errorLang"))
        Set ThisText = $GET(RS.Data("renderedContent"))

        Set BgnInx = $FIND(ThisText, MarkerBgn)
        Set EndInx = $FIND(ThisText, MarkerEnd) - $LENGTH(MarkerEnd)
        Set MarkerData = $ZSTRIP($EXTRACT(ThisText, BgnInx, EndInx), "<>W")

        Write ErrorTotal, SEP, ThisID, SEP, ThisFile, SEP, ThisLang, SEP, ThisErrLang, SEP, MarkerData, !
    }

    Quit $$$OK
]]></Implementation>
</Method>

<Method name="XMLExport">
<Description>
 Export a document as an xml document</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>key:cdata,filename:cdata=""</FormalSpec>
<Implementation><![CDATA[

    // find element name for key
    Set block = ##class(block).OpenKey(key)

    If (block = "") {
        Write "Utils:XMLExport() ", $$$T("Invalid key"),!
        Quit
    }

    Set top = block.%ClassName()

    If (filename '= "") {
        Open filename:("WSN"):2 Else  Write $$$T("XML Export: Unable to open file: "),filename,! QUIT
        Set io=$io
        Use filename

        // Set up correct file translation
        Do $zu(96,18,2,"UTF8")
    }

    // XML header
    Write "<?xml version=""1.0"" encoding=""UTF-8""?>",!
    Write "<!DOCTYPE ",top," PUBLIC ""-//Arbortext//DTD DocBook XML V4.0//EN"" ""X:\doc\common\metadata\doctypes\axdocbook\axdocbook.dtd"">",!

    // Now get block to render itself
    Do block.XMLRender()

    If (filename '= "") {
        Use io
        Close filename
    }

    quit
]]></Implementation>
</Method>

<Method name="XMLExportAll">
<Description>
Extracts all books and articles as singleton XML files into the specified directory.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>TargetDir:%String,Trace:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    ; initialize the result
    set filelist = ""

    ; prepare the query
    set ResultSet = ##class(%Library.ResultSet).%New("%Library.DynamicQuery:SQL")
    if (ResultSet = "")
    {
        set errmsg = $$$T("Cannot allocate result set")
        write errmsg, !
        quit $$$ERROR($$$GeneralError, errmsg)
    }
    set QueryText = "SELECT ID, blockid, dbrole"
    set QueryText = QueryText  _ " "
    set QueryText = QueryText  _ "FROM DocBook.article"
    set QueryText = QueryText  _ " "
    set QueryText = QueryText  _ "UNION"
    set QueryText = QueryText  _ " "
    set QueryText =  QueryText  _ "SELECT ID, blockid, dbrole"
    set QueryText = QueryText  _ " "
    set QueryText = QueryText  _ "FROM DocBook.book"
    set QueryText = QueryText  _ " "
    set QueryText = QueryText   _ "ORDER BY blockid"
    ; write QueryText, !

    set Status = ResultSet.Prepare(QueryText)
    if (Status = "")
    {
        do $system.OBJ.DisplayError(Status)
        quit $$$ERROR($$$GeneralError,$$$T("Error compiling extract query"))
    }

    ; apply it
    set SQLCODE = 0
    do ResultSet.Execute()
    if (SQLCODE '= 0)
    {
        write !, $$$T("SQLCODE = "), SQLCODE
        quit $$$ERROR($$$GeneralError,$$$T("Error executing extract query"))
    }

    ; iterate over the items
    while (ResultSet.Next(.status))
    {
        if ($$$ISERR(status))
        {
            write $$$ERROR($$$GeneralError,$$$T("Error returning loaded documents"))
            quit
        }
        ; get the book name
        set itemid = ResultSet.Get("ID")
        set itemname = ResultSet.Get("blockid")
        set itemrole = ResultSet.Get("dbrole")
        set keepflag = ('((itemname = "") || ($ZCONVERT(itemrole, "L") = "tutorial")))
        ; append the new name
        set:(keepflag) filelist = filelist _ $LISTBUILD(itemname)
    }

    ; finished
    do ResultSet.Close()
    set ResultSet = ""

    ; create the output direcory
    set targetdir = ##class(%Library.File).NormalizeDirectory(TargetDir)
    if ('(##class(%Library.File).CreateDirectoryChain(targetdir)))
    {
        set errmsg = $$$T("Cannot create output directory: ") _ targetdir
        write errmsg, !
        quit $$$ERROR($$$GeneralError, errmsg)
    }

    for i = 1 : 1 : $LISTLENGTH(filelist)
    {
        set name = $LIST(filelist, i)
        set outputfile = targetdir _ name _ ".xml"
        write:(Trace) $$$T("Export: "), name, !
        do ..XMLExport(name, outputfile)
    }

    ;done
    quit $$$OK
]]></Implementation>
</Method>

<Method name="Reset">
<Description>
Clear the entire DocBook database.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Kill ^DocBook.blockD
    Kill ^DocBook.blockI
    Kill ^DocBook.blockID
    Kill ^DocBook.OffLine
    Kill ^DocBook.LoadTime
    Kill ^DocBook.ErrorLogD

    Do ..ResetIndex()
]]></Implementation>
</Method>

<Method name="ResetIndex">
<Description>
Clear the Master Index list.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[    Kill ^DocBook.Index
]]></Implementation>
</Method>

<Method name="ResetLog">
<Description>
Clear the contents of the error log.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[    Do ##class(ErrorLog).Reset()
]]></Implementation>
</Method>

<Method name="ShowLog">
<Description>
Display the error log</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[    Do ##class(ErrorLog).List()
]]></Implementation>
</Method>

<Method name="RenderContainer">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>cid:cdata,indent:%Integer=0</FormalSpec>
<Implementation><![CDATA[

    // find child blocks
    &sql(DECLARE C1 CURSOR FOR
         SELECT ID,content,x__classname
         INTO :bid,:content,:cls
         FROM block
         WHERE container = :cid
         ORDER BY blockpos
    )

    &sql(OPEN C1)
    &sql(FETCH C1)

    Write ?indent,bid,!

    While (SQLCODE = 0) {
        Do ..RenderContainer(bid,indent+5)
        &sql(FETCH C1)
    }

    &sql(CLOSE C1)
]]></Implementation>
</Method>

<Method name="CheckLinks">
<Description>
Check all links within the documentation database
Returns (by reference) the number of links,
the number of badlinks, and the targets of all bad
links (in an array subscripted by link #).</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&total:%Integer,&bad:%Integer,&badlist:%String,&static:%Integer,&staticlist:%String,silent:%Boolean=1]]></FormalSpec>
<Implementation><![CDATA[

    // search text for links
    // disable olink checking
    //&sql(DECLARE LinkCursor CURSOR FOR
    //        SELECT ID, blockid, content, sourceFile
    //        INTO    :id ,:key, :text , :src
    //        FROM DocBook.block
    //        WHERE (content [ '<ulink') OR (content [ '<olink') )
    &sql(DECLARE LinkCursor CURSOR FOR
            SELECT ID, blockid, content, sourceFile
            INTO    :id ,:key, :text , :src
            FROM DocBook.block
            WHERE (content [ '<ulink'))

    &sql(OPEN LinkCursor)

    &sql(FETCH LinkCursor)
    Set total = 0
    Set bad = 0

    Set row = 1
    While (SQLCODE = 0) {
        Write:'silent !,$$$T("Checking: "),key," "

        Do ..CheckLinksInText(src,text,.total,.bad,.badlist,.static,.staticlist,silent)

        &sql(FETCH LinkCursor)
        Set row = row + 1
    }

    &sql(CLOSE LinkCursor)

    If ('silent) {
        // write report
        If (bad > 0) {
            Write !,"------------------",!
            Write $$$T("BAD LINKS:"),!
            For i = 1:1:bad {
                Write ?5,$LG(badlist(i),1),?30,$LG(badlist(i),2),!
            }
        }

        Write !,"------------------",!
        Write $$$T("Links:     "),total,!
        Write $$$T("Bad Links: "),bad,!
    }
]]></Implementation>
</Method>

<Method name="CheckLinksInText">
<Description>
Checks a block of text for bad links;</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[src:%String,txt:%String,&total:%Integer,&bad:%Integer,&badlist:%String,&static:%Integer,&staticlist:%String,silent:%Boolean=1]]></FormalSpec>
<Implementation><![CDATA[

    // we assume that text has a link in it
    // or else we would not be here.
    Set tokens = ##class(%CSP.TokenStream).%New()
    Do tokens.OpenFromString(txt)

    While (tokens.NextToken()) {
        Set url = ""
        If (tokens.Tag = "ulink") {
            Set attrs = ""
            Do tokens.GetAttrs(.attrs)
            // 'url' attribute of ulink tag contains link
            Set url = $G(attrs("url","value"))
        }
        //ElseIf (tokens.Tag = "olink") {
        //    Set attrs = ""
        //    Do tokens.GetAttrs(.attrs)
        //    // 'type' attribute of olink tag contains link
        //    Set url = $G(attrs("type","value"))
        //}

        Set url = $ZCONVERT(url, "I", "HTML")

        If (url '= "") {
            If ((url [ "http:") || (url [ "https:") || (url [ "ftp:") || (url [ ".html") || (url [ "www.") || (url [ ".htm") || (url [ ".cls") || (url [ ".csp")) {
                // not an internal link
                Set static = static + 1
                Set staticlist(static) = $LB(src,url)
            }
            Else {
                Set total = total + 1
                // test this link
                Set id = ##class(DocBook.block).FindId(url)
                If ((id = "") && ($ZCVT(url,"U") '= "KNBASE")) {
                    Write:'silent "*"
                    Set bad = bad + 1
                    Set badlist(bad) = $LB(src,url)
                }
            }
        }
    }
]]></Implementation>
</Method>

<Method name="BuildAnchorIndex">
<Description>
Create an index in the ^DocBook.Index global</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[

    //clear any existing index
    Kill ^DocBook.Anchor

    // iterate over all that are defined
    &sql(DECLARE ANCHORC CURSOR FOR
        SELECT ID, blockid, target
        INTO :blocknum, :blockid, :target
        FROM DocBook.anchor)


    &sql(OPEN ANCHORC)
    &sql(FETCH ANCHORC)

    While (SQLCODE = 0)
    {
        Set subs = ##class(DocBook.PortalUtils).FormatSubscript(target)
        Set ref = "^DocBook.Anchor" _ "(" _ subs _ ")"
        If (subs  = """""")
        {
            Write $$$T("Empty subscript at block "), blocknum, "; ", $$$T("id "), blockid, !
        }
        Else
        {
            Set @ref = blockid
        }

        Set lastchr = $EXTRACT(blockid, *)
        Set suffix = "_anchor"
        If ("0123456789" [ lastchr)
        {
            Set suffix = suffix _ lastchr
        }
        Set refblock = $REPLACE(blockid, suffix, "")
        Set refobj = ##class(DocBook.block).FindId(refblock)
        If (refobj = "")
        {
            Write $$$T("Warning: Missing anchor reference: "), refblock,!
        }

        &sql(FETCH ANCHORC)
    }

    &SQL(CLOSE ANCHORC)
]]></Implementation>
</Method>

<Method name="BuildIndex">
<Description>
Create an index in the ^DocBook.Index global</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[

    // clear index
    Kill ^DocBook.Index
    Set ^DocBook.IndexTime = $zdt($H,3)

    // first get list of titles (books, chapters, etc)
    &sql(DECLARE ABIT CURSOR FOR
        SELECT blockid, title , component->blockid, x__classname, book->title
        INTO :blockid, :title, :dockey, :xcls, owner
        FROM DocBook.component)

    &sql(OPEN ABIT)
    &sql(FETCH ABIT)

    While (SQLCODE = 0) {
        If (title '= "") {
            // pull out classname
            Set type = $P(xcls,"~",$L(xcls,"~")-1)
            Set type = $P(type,".",$L(type,"."))

            Do ..AddEntry(title,type,blockid,dockey,owner)
        }
        &sql(FETCH ABIT)
    }

    &sql(CLOSE ABIT)

    // now get list of sect1 titles
    &sql(DECLARE BIS1 CURSOR FOR
        SELECT blockid, title , component->blockid, book->title
        INTO :blockid, :title, :dockey, owner
        FROM DocBook.sect1)

    &sql(OPEN BIS1)
    &sql(FETCH BIS1)

    While (SQLCODE = 0) {
        If (title '= "") {
            Do ..AddEntry(title,"sect1",blockid,dockey,owner)
        }
        &sql(FETCH BIS1)
    }

    &sql(CLOSE BIS1)

    // now get list of sect2 titles
    &sql(DECLARE BIS2 CURSOR FOR
        SELECT blockid, title , component->blockid, book->title
        INTO :blockid, :title, :dockey, owner
        FROM DocBook.sect2)

    &sql(OPEN BIS2)
    &sql(FETCH BIS2)

    While (SQLCODE = 0) {
        If (title '= "") {
            Do ..AddEntry(title,"sect2",blockid,dockey,owner)
        }
        &sql(FETCH BIS2)
    }

    &sql(CLOSE BIS2)

    // now get list of glossary terms
    &sql(DECLARE BIG CURSOR FOR
        SELECT blockid,glossterm,component->blockid,book->title
        INTO :blockid, :title, :dockey, :owner
        FROM DocBook.glossentry)

    &sql(OPEN BIG)
    &sql(FETCH BIG)

    While (SQLCODE = 0) {
        If (title '= "") {
            Do ..AddEntry(title,"glossentry",blockid,dockey,owner)
        }
        &sql(FETCH BIG)
    }

    &sql(CLOSE BIG)

     // now get list of marked index entries

    // find candidate blocks
    &sql(DECLARE BII CURSOR FOR
        SELECT content,blockid,component->blockid,book->title
        INTO :text,:blockid,:dockey,:owner
        FROM DocBook.block
        WHERE content [ '<indexterm')

    &sql(OPEN BII)
    &sql(FETCH BII)

    While (SQLCODE = 0) {
        If (title '= "") {
            Do ..AddMarkedEntry(text,blockid,dockey,owner)
        }
        &sql(FETCH BII)
    }

    &sql(CLOSE BII)
]]></Implementation>
</Method>

<Method name="AddEntry">
<Description>
Add an entry to the index global.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>title,source,blockid,dockey,owner=""</FormalSpec>
<Implementation><![CDATA[

    // first remove any leading articles;
    // (this is English-specific)
    Set fword = $P(title," ",1)
    If (",A,AN,THE," [ ("," _ $ZCVT(fword,"U") _ ",")) {
        Set title = $P(title," ",2,$L(title," ")) _ ", " _ fword
    }

    // collate title

    // !!! hack for leading "<"
    Set ctitle = title
    If ($E(ctitle,1,4) = "&lt;") {
        Set ctitle = $E(ctitle,5,*)
    }

    // strip whitespace
    // !!! this strips too much white space
    Set ctitle = " "_$zcvt($zstrip(ctitle,"*P"),"U")
    If ($LENGTH(ctitle) > 250)
    {
        Write "Cannot index blockid ", blockid, "; len = ", $LENGTH(ctitle), "; value[", ctitle, "]", !
        Quit
    }
    Set n = 1 + $Order(^DocBook.Index(ctitle,""),-1)
    If (dockey = "") {
        Set link = "KEY=" _ blockid
    }
    Else {
        Set link = "KEY=" _ dockey _ "#" _ blockid
    }

    Set ^DocBook.Index(ctitle,n) = $LB(title,link,source,owner)
]]></Implementation>
</Method>

<Method name="AddMarkedEntry">
<Description>
Search the text and find the index entries in it.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>text,blockid,dockey,owner=""</FormalSpec>
<Implementation><![CDATA[

    // Scan for any index terms
    Set bgntag = "<indexterm"
    Set endtag = "</indexterm"
    Set closure = ">"

    Set termlist = ""
    Set f1 = 0
    While (1)
    {
        Set f1 = $FIND(text, bgntag, f1)
        Quit:(f1 = 0)
        Set termbgn = f1 - $LENGTH(bgntag)
        Set f2 = $FIND(text, endtag, f1)
        Set termend = $FIND(text, closure, f2)
        Set holder = $EXTRACT(text, termbgn, (termend -1))
        ; Write "Fragment: ", holder, !
        ; remove any <indexterm> containing a <see> or <seealso>
        if ('((holder [ "<see") || (holder [ "<seealso")))
        {
            Set termlist = termlist _ $LISTBUILD(holder)
        }
        Set f1 = termend
    }

    If ($LISTLENGTH(termlist) > 0)
    {
        ; Write "Terms: ", $LISTLENGTH(termlist), !
        For n = 1 : 1 : $LISTLENGTH(termlist)
        {
            Set text = $LIST(termlist, n)
            ; Write "Text: ", text, !

            // Remove the seealso and see references (in that order)
            For tag = "seealso", "see"
            {
                Set f1 = 0
                While (1)
                {
                    Set f1 = $FIND(text, ("<" _ tag), f1)
                    Quit:(f1 = 0)
                    ; Write text, !
                    Set f1 = f1 - $LENGTH(tag) - 1
                    Set f2 = $FIND(text, ("</" _ tag _ ">"), f1)
                    Set $EXTRACT(text, f1, (f2 - 1)) = ""
                }
            }
            ; Write "See/Seealso: ", text, !

            // Change the secondary and tertiary terms (in that order)
            Set holder = ""
            For tag = "secondary", "tertiary"
            {
                Set f1 = 0
                While (1)
                {
                    Set scanner = "<" _ tag
                    Set f1 = $FIND(text, scanner, f1)
                    Quit:(f1 = 0)
                    ; Write text, !
                    Set f1 = f1 - $LENGTH(scanner)
                    Set bgntext = $FIND(text, ">", f1)
                    Set scanner = "</" _ tag _ ">"
                    Set f2 = $FIND(text, scanner, bgntext)
                    Set endtext = f2 - $LENGTH(scanner) - 1
                    ; Write "Found: ", $EXTRACT(text, bgntext, endtext), !
                    Set holder = holder _ " &raquo; " _ $EXTRACT(text, bgntext, endtext)
                    Set $EXTRACT(text, f1, (f2 - 1)) = ""
                    ; Write "Holder: ", holder, !
                    ; Write tag, ": ", text, !

                }
            }

            // Now extract the primary reference
            Set tag = "primary"
            Set f1 = 0
            While (1)
            {
                Set f1 = $FIND(text, ("<" _ tag), f1)
                Quit:(f1 = 0)
                Set f1 = f1 - $LENGTH(tag) - 1
                Set bgntext = $FIND(text, ">", f1)
                Set f2 = $FIND(text, ("</" _ tag _ ">"), bgntext)
                Set endtext = f2 - $LENGTH(tag) - 3 - 1
                Set key = $EXTRACT(text, bgntext, endtext) _ holder
                ; Write "==> ", key, !
                Do ..AddEntry(key,"block",blockid,dockey,owner)
                Set f1 = f2
                Set holder = ""
            }
        }
    }

    Quit
]]></Implementation>
</Method>

<Method name="CountGlobal">
<Description>
Counts the number of members in the global</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>GlobName:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
    Set Cnt = 0

    Set Sub = ""
    Set Ref = $QUERY(@GlobName@(Sub))
    While (Ref '= "")
    {
        Set Cnt = Cnt + 1
        Set Ref = $QUERY(@Ref)
    }

    Quit Cnt
]]></Implementation>
</Method>

<Method name="Colorize">
<Description>
Syntax color all the programlisting blocks</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[

    &sql(DECLARE CC CURSOR FOR
        SELECT ID
        INTO :id
        FROM DocBook.programlisting
        WHERE dblang IS NOT NULL
    )

    &sql(OPEN CC)
    &sql(FETCH CC)

    Set count = 0
    Write $$$T("Colorizing...")

    While (SQLCODE = 0) {
        Set count = count + 1
        Set block = ##class(programlisting).%OpenId(id)

        Do block.Colorize()

        Do block.%Save()
        &sql(FETCH CC)
    }

    Write !,count,$$$T(" blocks colorized."),!

    &sql(CLOSE CC)
]]></Implementation>
</Method>

<Method name="ExecuteSample">
<Description>
Execute the given sample program (assuming this is called
from a CSP page)</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>content:%String,lang:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    If (lang = "COS") {
        &html<<DIV CLASS="OUTPUT">>
        Set sc = ..ExecuteCOS(content)
        &html<</DIV>>
    }
    ElseIf (lang = "BAS") {
        &html<<DIV CLASS="OUTPUT">>
        Set sc = ..ExecuteBAS(content)
        &html<</DIV>>
    }
    ElseIf (lang = "CSP") {
        &html<<DIV CLASS="OUTPUT">>
        Set sc = ..ExecuteCSP(content)
        &html<</DIV>>
    }
    ElseIf (lang = "SQL") {
        Set sc = ..ExecuteSQL(content)
    }
    Else {
        Set sc = $$$OK
    }

    Quit sc
]]></Implementation>
</Method>

<Method name="ExecuteCOS">
<Description>
Execute a COS example</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>code:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    // execute in SAMPLES namespace

    Set zn = $zu(5)
    Set x = $zu(5,"SAMPLES")


    Set routine = ##class(%Routine).%New("DocBook.EXECTemp1COS.MAC")

    // Write lines of code to the routine
    Do routine.WriteLine("EXECTemp1COS ;"_$ZDT($H,3))

    // UNIX nonsense!
    Set code = $TR(code,$C(13),"")

    // get rid of HTML escapes
    Set code = $ZCVT(code,"I","HTML")

    For ln = 1:1:$L(code,$C(10)) {
        Do routine.WriteLine($P(code,$C(10),ln))
    }

    Do routine.WriteLine("")
    Do routine.WriteLine(" QUIT")

    Write "<PRE>"

    // save the routine
    Do routine.Save()

    // compile the routine (with no output)
    Set sc = routine.Compile("-d")

    If ($$$ISERR(sc)) {
        Do $system.OBJ.DisplayError(sc)
    }
    Else {
        // save current translate table
        //Set iomode = $zu(96, 18, 0)
        // translate output using HTML escapes
        //Do $zu(96, 18, 2, "HTML")

        // execute the new routine
        Do ^DocBook.EXECTemp1COS

        // restore translate table
        //Do $zu(96, 18, 2, iomode)
    }

    Write "</PRE>"

    // restore old namespace
    Set x = $zu(5,zn)

    Quit $$$OK
]]></Implementation>
</Method>

<Method name="ExecuteBAS">
<Description>
Execute a BASic example</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>code:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    // execute in SAMPLES namespace

    Set zn = $zu(5)
    Set x = $zu(5,"SAMPLES")

    Set routine = ##class(%Routine).%New("DocBook.EXECTemp1BAS.BAS")

    // Write lines of code to the routine
    Do routine.WriteLine("' EXECTemp1BAS "_$ZDT($H,3))

    // UNIX nonsense!
    Set code = $TR(code,$C(13),"")

    // get rid of HTML escapes
    Set code = $ZCVT(code,"I","HTML")

    For ln = 1:1:$L(code,$C(10)) {
        Do routine.WriteLine($P(code,$C(10),ln))
    }

    Write "<PRE>"

    // save the routine
    Do routine.Save()

    // compile the routine
    Set sc = routine.Compile("-d")

    If ($$$ISERR(sc)) {
        Do $system.OBJ.DisplayError(sc)
    }
    Else {
        // execute the new routine
        Do ^DocBook.EXECTemp1BAS
    }
    Write "</PRE>"

    // restore old namespace
    Set x = $zu(5,zn)

    Quit $$$OK
]]></Implementation>
</Method>

<Method name="ExecuteSQL">
<Description>
Execute an SQL example</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>code:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    // execute in SAMPLES namespace

#dim x,zn As %String
#dim i,splitSQL As %Integer

    Set zn = $zu(5)
    Set x = $zu(5,"SAMPLES")

    Set routine = ##class(%Routine).%New("DocBook.EXECTemp1COS.MAC")

    // Write lines of code to the routine
    Do routine.WriteLine("EXECTemp1COS ;"_$ZDT($H,3))

    // convert CR to spaces
    if code[$c(13,10),code["--" { set splitSQL=1 }
    else { Set splitSQL=0, code = $TR(code,$C(13,10),"  ") }

    // get rid of HTML escapes
    Set code = $ZCVT(code,"I","HTML")

    // write code to execute query
    if splitSQL {
        Do routine.WriteLine(" New query,sc,col,cols,data,sql")
        Do routine.WriteLine(" Set query = ##class(%ResultSet).%New()")
        for i=1:1:$l(code,$c(13,10)) {
            Do routine.WriteLine($s(i=1:" Set sql="_$l(code,$c(13,10)),1:"")_" Set sql("_i_") = "_$zu(144,1,$p(code,$c(13,10),i)))
        }
        Do routine.WriteLine(" Set sc = query.Prepare(.sql,,""DISPLAY"")")
    }
    else {
        Do routine.WriteLine(" New query,sc,col,cols,data")
        Do routine.WriteLine(" Set query = ##class(%ResultSet).%New()")
        Do routine.WriteLine(" Set sc = query.Prepare(" _ $ZU(144,1,code) _ ",,""DISPLAY"")")
    }
    Do routine.WriteLine(" If (+sc = 0) {")
    Do routine.WriteLine("  Do $system.OBJ.DisplayError(sc)")
    Do routine.WriteLine("  QUIT")
    Do routine.WriteLine(" }")

    Do routine.WriteLine(" Set sc = query.Execute()")
    Do routine.WriteLine(" If (+sc = 0) {")
    Do routine.WriteLine("  Do $system.OBJ.DisplayError(sc)")
    Do routine.WriteLine("  QUIT")
    Do routine.WriteLine(" }")

    // use border=1 for netscape
    Do routine.WriteLine(" Set b=$S(%request.UserAgent[""MSIE"":0,1:1)")

    Do routine.WriteLine(" Write ""<TABLE BORDER="",b,"" BGCOLOR=""""white"""" CELLPADDING=1 CELLSPACING=0 CLASS=""""SQL""""><TR>""")
    Do routine.WriteLine(" Set cols = query.GetColumnCount()")

    Do routine.WriteLine(" For col = 1:1:cols {")
    Do routine.WriteLine("  Write ""<TH>"",query.GetColumnHeader(col),""</TH>"",!")
    Do routine.WriteLine(" }")
    Do routine.WriteLine(" Write ""</TR>""")

    Do routine.WriteLine(" While (query.Next()) {")
    Do routine.WriteLine(" Write ""<TR>"",!")
    Do routine.WriteLine("  For col = 1:1:cols {")
    Do routine.WriteLine("   Set data = query.GetData(col)")
    Do routine.WriteLine("   Write ""<TD>"",$S(data="""":""<I>&lt;null&gt;</I>"",1:$ZCVT(data,""O"",""HTML"")),""</TD>"",!")
    Do routine.WriteLine("  }")
    Do routine.WriteLine(" Write ""</TR>"",!")
    Do routine.WriteLine(" }")
    Do routine.WriteLine(" Write ""</TABLE>""")

    Do routine.WriteLine(" Do query.Close()")
    Do routine.WriteLine(" QUIT")

    // save the routine
    Do routine.Save()

    // compile the routine
    Set sc = routine.Compile("-d")

    If ($$$ISERR(sc)) {
        Do $system.OBJ.DisplayError(sc)
    }
    Else {
        // execute the new routine
        Do ^DocBook.EXECTemp1COS
    }

    // restore old namespace
    Set x = $zu(5,zn)

    Quit $$$OK
]]></Implementation>
</Method>

<Method name="ExecuteCSP">
<Description>
Execute a CSP example: note that CSP tags are not supported</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>code:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    // execute in SAMPLES namespace

    Set zn = $zu(5)
    Set x = $zu(5,"SAMPLES")

    Set routine = ##class(%Routine).%New("DocBook.EXECTemp1COS.MAC")

    // Write lines of code to the routine
    Do routine.WriteLine("EXECTemp1COS ;"_$ZDT($H,3))

    // UNIX nonsense!
    Set code = $TR(code,$C(13),"")

    // get rid of HTML escapes
    Set code = $ZCVT(code,"I","HTML")

    Do routine.WriteLine(" &html<")

    For ln = 1:1:$L(code,$C(10)) {
        Do routine.WriteLine($P(code,$C(10),ln))
    }

    Do routine.WriteLine(">")
    Do routine.WriteLine(" QUIT")

    // save the routine
    Do routine.Save()

    // compile the routine
    Set sc = routine.Compile("-d")

    If ($$$ISERR(sc)) {
        Do $system.OBJ.DisplayError(sc)
    }
    Else {
    // execute the new routine
        Do ^DocBook.EXECTemp1COS
    }

    // restore old namespace
    Set x = $zu(5,zn)

    Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetBuildInfo">
<Description><![CDATA[
Generates the version info string for the DocBook database.<BR>
This is invoked when the database is built.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>entity:%Boolean=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    quit ("Cach"
          _ $SELECT(entity:"&eacute;", 1:"e")
          _ " v"
          _ $system.Version.GetNumber()
          _ " ("
          _ $system.Version.GetCompBuild()
          _ ")")
]]></Implementation>
</Method>

<Method name="SetBuildInfo">
<Description><![CDATA[
Set the version info for the DocBook database.<BR>
This is invoked when the database is built.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[    Set ^DocBook.BuildInfo = ..GetBuildInfo()
]]></Implementation>
</Method>
</Class>
</Export>
